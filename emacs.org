
#+TITLE: Emacs Configuration
#+OPTIONS:   H:4 num:nil toc:t \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+INFOJS_OPT: view:nil toc:t ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js
#+STYLE:    <link rel="stylesheet" type="text/css" href="/static/files/emacs-config.css" />


This file is used by [[http://orgmode.org/worg/org-contrib/babel/intro.php#sec-8_2_1][org-babel]] to generate ~emacs.el~ from
it. ~emacs.el~ is then loaded as my Emacs configuration and only
re-generated when the org file changes. Ideas taken from from Andi Albrecht https://raw.githubusercontent.com/andialbrecht/emacs-config/master/emacs.org


* Globals
All lisp files needed to run this configuration are either installed
by system packages. Or found in the same directory where this
configuration file lives. The path to this configuration directory is
bound to ~dotfiles-dir~ in the main ~init.el~.

* Packages
** Install packages
#+begin_src emacs-lisp
  ;; Add MELPA to packages sources
  ;; Inspired by http://melpa.milkbox.net/#/getting-started
  (require 'package)
  (add-to-list 'package-archives
    '("melpa" . "http://melpa.milkbox.net/packages/") t)
  ;; On older emacsen also add the base library
  (when (< emacs-major-version 24)
    (add-to-list 'package-archives '("gnu" . "http://elpa.gnu.org/packages/")))  

  ;; Initialize packages
  (package-initialize)
#+end_src
* Magit configuration
*** Key binding
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x g") 'magit-status) 
(global-set-key (kbd "<f12>") 'magit-status) 
#+END_SRC
*** Windows specific
GIT on Windows does not play nicely with EMACS. This is a hack to fix that and show a GUI password box instead of the normal one. Ugly.
**** TODO Check if this works also in OS X
#+begin_src emacs-lisp
   (setenv "GIT_ASKPASS" "git-gui--askpass")
#+end_src
Adding the following to =.git/config= helps to avoid typing the username over and over:
#+begin_src 
[credential "https://github.com"]
	username = pragtich
#+end_src
Also, it is very slow when the PATH is not clear. This may help: (https://stackoverflow.com/questions/16884377/magit-is-very-slow-when-committing-on-windows)
#+begin_src emacs-lisp
 (if (eq system-type 'windows-nt)
    (progn
      (setq exec-path (add-to-list 'exec-path "C:/Users/jpg/Progs/Git/bin"))
     ))
#+end_src
**** TODO Change GIT_ASKPASS item in emacs.org to only act on Windows (test on OSX)

* Org-mode 
** Locations
Need to set system-specific locations for org, as I keep everything in Dropbox and cannot do symlinks in Windows. So I set =org-directory= as a home location. I can then use this as a base for the file named in =org-agenda-files=, which lists files on each line relative to this folder.
#+BEGIN_SRC emacs-lisp
(if (eq system-type 'windows-nt) ; Actually trying to detect my work pc, may need to change this later on
  (setq org-directory (substitute-in-file-name "$USERPROFILE/Dropbox/org/"))
  (setq org-directory "~/org/")
)

(setq org-agenda-files "~/.emacs.d/org-agenda-files") ; Use a single file name, so lookup agenda files in that file (see help on org-agenda-files)
#+END_SRC
** Notes on updating org
I am using git, so org updating is something to do with =git submodule=. Google to find it. Anyway, this is important: http://orgmode.org/worg/org-hacks.html#compiling-org-without-make
** Keybindings
We need some keybindings for org-mode. These are the suggested defaults.
#+BEGIN_SRC emacs-lisp
(global-set-key "\C-cl" 'org-store-link)
(global-set-key "\C-ca" 'org-agenda)
#+END_SRC
** Start org-mode for all .org files
Somewhat superfluous since recent Emacsen have this as default, but just in case:
#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.org\\'" . org-mode))
#+END_SRC
** Org mode easy templates: source code with emacs list tag. 
This is primarily to ease editing of this single file: enter =<S= and hit =TAB= to make a source template with the =emacs-lisp= language.
#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-structure-template-alist (list "S" "#+BEGIN_SRC emacs-lisp?\n\n#+END_SRC" "<src lang=\"?\">\n\n</src>" ))
#+END_SRC

** Prevent M-RET from splitting lines
I hate it when =<M-RET>= splits a line in the middle, something I never do.
#+BEGIN_SRC emacs-lisp
(setq org-M-RET-may-split-line nil)
#+END_SRC

** Use IDO mode for org
#+BEGIN_SRC emacs-lisp
(setq org-completion-use-ido t)
#+END_SRC

** Hide leading stars
#+BEGIN_SRC emacs-lisp
(setq org-hide-leading-stars t)
#+END_SRC

** Fontify src blocks
#+BEGIN_SRC emacs-lisp
(setq org-src-fontify-natively t)
#+END_SRC
** Custom agenda commands
*** Define stuck projects
#+BEGIN_SRC emacs-lisp
(setq org-stuck-projects '("Project/-DONE" nil ("NEXT") ""))
#+END_SRC
*** Daily agenda view
#+BEGIN_SRC emacs-lisp
  (if (not (boundp 'org-agenda-custom-commands)) (set 'org-agenda-custom-commands ()) )

  (push 
    '("A" "Joris' daily agenda view" (
      (todo "A" ((org-agenda-overriding-header "Wat moet er vandaag in ieder geval gebeuren:"))) 
      (tags "NEXT" ((org-agenda-overriding-header "Volgende acties voor de projecten:")))
      (stuck "" nil)) 
     ((org-agenda-prefix-format 
       '((agenda . " %i %-12:c%?-12t% s")
       (timeline . "  % s")
;       (todo . "%(concat \"[\" (format \"%-15s\" (org-format-outline-path (org-get-outline-path) 13)) \"] \")")
       (todo . "%(concat \"[\" (format \"%-15s\" (or (car (last (org-get-outline-path)))) \"\") \"] \")")
;       (tags . "%(concat \"[\" (format \"%-15s\" (org-format-outline-path (org-get-outline-path) 13)) \"] \")")
       (tags . "%(concat \"[\" (format \"%-15s\" (or (car (last (org-get-outline-path) ))) \"\") \"] \")")
       (search . " %i %-8:c"))
      )) ())       
      org-agenda-custom-commands )

#+END_SRC
** Custom TODO headers
#+BEGIN_SRC emacs-lisp
(setq org-todo-keywords
      '((sequence "B(b)" "A(a)" "C(c)" "WAITING(w)" "|" "DONE(d)" ))) 
#+END_SRC
** Fast TAGS selection
Using +TAGS: NEXT(n) format helps greatly
#+BEGIN_SRC emacs-lisp
(setq org-fast-tag-selection-single-key t)
#+END_SRC
* Look and feel
** Behavior
*** Small things
These lines configure Emacs' general behavior at certain aspects.
**** Show matching parentheses
#+begin_src emacs-lisp
  ;; show matching parens
  (show-paren-mode 1)
#+end_src
**** Change yes or no to y-or-n>
#+begin_src emacs-lisp
  ;; take the short answer, y/n is yes/no
  (defalias 'yes-or-no-p 'y-or-n-p)
#+end_src
**** Indentation after RET
I almost always want to go to the right indentation on the next line.
#+begin_src emacs-lisp
(global-set-key (kbd "RET") 'newline-and-indent)
#+end_src
*** Sentences end with a single space

In my world, sentences end with a single space. This makes
sentence navigation commands work for me.

#+begin_src emacs-lisp
  (setq sentence-end-double-space nil)
#+end_src
*** Prefer to split windows vertically
#+BEGIN_SRC emacs-lisp
(setq split-height-threshold 60)
(setq split-width-threshold 90)
#+END_SRC
*** IDO mode
**** Basic configuration of the great IDO mode taken from http://www.masteringemacs.org/articles/2010/10/10/introduction-to-ido-mode/.
#+BEGIN_SRC emacs-lisp
  (setq ido-enable-flex-matching t)
  (setq ido-everywhere t)
  (ido-mode 1) 
#+END_SRC
**** Prevent IDO from asking when I just want to make a scratch buffer.
#+BEGIN_SRC emacs-lisp
 	
(setq ido-create-new-buffer 'always)

#+END_SRC
**** Ignore predefined useless extensions
     Which are defined in =completion-ignored-extensions=.
#+BEGIN_SRC emacs-lisp

(setq ido-ignore-extensions t) 

#+END_SRC
**** Key shortcuts for IDO
I like being able to move to next and prev hits in IDO
#+BEGIN_SRC emacs-lisp
;; Set ido next-previous match keys
(add-hook 'ido-setup-hook (lambda ()
  (define-key ido-completion-map (kbd "C-n") 'ido-next-match)
  (define-key ido-completion-map (kbd "C-p") 'ido-prev-match)))
#+END_SRC
**** M-x mode
Adding =M-x= mode to IDO:
#+BEGIN_SRC emacs-lisp
;; Reenable ido for M-x
(setq ido-ubiquitous-command-overrides
  (cons '(enable exact "execute-extended-command") (cdr ido-ubiquitous-default-command-overrides)))
#+END_SRC
#+BEGIN_SRC emacs-lisp :tangle no
  (global-set-key
     "\M-x"
     (lambda ()
       (interactive)
       (call-interactively
        (intern
         (ido-completing-read
          "M-x "
          (all-completions "" obarray 'commandp))))))

#+END_SRC

*** Delete current buffer file
Deleting current buffer and the file it is visiting using the very logical =C-x C-k=(http://whattheemacsd.com/).
#+BEGIN_SRC emacs-lisp
(defun delete-current-buffer-file ()
  "Removes file connected to current buffer and kills buffer."
  (interactive)
  (let ((filename (buffer-file-name))
        (buffer (current-buffer))
        (name (buffer-name)))
    (if (not (and filename (file-exists-p filename)))
        (ido-kill-buffer)
      (when (yes-or-no-p "Are you sure you want to remove this file? ")
        (delete-file filename)
        (kill-buffer buffer)
        (message "File '%s' successfully removed" filename)))))

(global-set-key (kbd "C-x C-k") 'delete-current-buffer-file)
#+END_SRC
*** Rename current buffer file
As in the delete version, it's really nice to be able to rename the visited file easily. Whattheemacsd uses =C-x C-r=, which I find very reasonable.
#+BEGIN_SRC emacs-lisp
(defun rename-current-buffer-file ()
  "Renames current buffer and file it is visiting."
  (interactive)
  (let ((name (buffer-name))
        (filename (buffer-file-name)))
    (if (not (and filename (file-exists-p filename)))
        (error "Buffer '%s' is not visiting a file!" name)
      (let ((new-name (read-file-name "New name: " filename)))
        (if (get-buffer new-name)
            (error "A buffer named '%s' already exists!" new-name)
          (rename-file filename new-name 1)
          (rename-buffer new-name)
          (set-visited-file-name new-name)
          (set-buffer-modified-p nil)
          (message "File '%s' successfully renamed to '%s'"
                   name (file-name-nondirectory new-name)))))))

(global-set-key (kbd "C-x C-r") 'rename-current-buffer-file)
#+END_SRC
*** Delete to trash
#+BEGIN_SRC emacs-lisp
( setq delete-by-moving-to-trash t)
#+END_SRC
*** Join lines
A tip from http://whattheemacsd.com/: use =M-j= to join two lines. Loses a =comment-indent-new-line=, which I will not miss.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-j")
  (lambda ()
  (interactive)
  (join-line -1)))
#+END_SRC
  
** Minimize Emacs' chrome
Hide a lot of default Emacs chrome, so that we just start with a
vanilla ~*scratch*~ buffer.

#+begin_src emacs-lisp
  ;; Remove unused UI elements
 (add-hook 'window-setup-hook (lambda () (tool-bar-mode -1))) 
;  (tool-bar-mode 0) Conflicts with maximization on windows, so need the hook above
  (menu-bar-mode 0)
  (scroll-bar-mode 0)
  (setq inhibit-startup-message t)
  
  ;; shhht, give me some time to think, don't blink
  (blink-cursor-mode 0)
  
#+end_src
** Theming
   (Obsolete) Make use of color-theme to make it pretty.
   Now switched to zenburn (does not require color-theme) because it better supports Org-mode. More info here: https://github.com/bbatsov/zenburn-emacs. Other options would be found here: http://orgmode.org/worg/org-color-themes.html
   #+begin_src emacs-lisp
;;    (require 'color-theme)
;;    (color-theme-initialize)
;;    (color-theme-kingsajz)
(load-theme 'zenburn t)
   #+End_src
* Backups and History
** Backups
  
From Sacha Chua (https://raw.githubusercontent.com/sachac/.emacs.d/gh-pages/Sacha.org).
This is one of the things people usually want to change right away. By default, Emacs saves backup files in the current directory. These are the files ending in =~= that are cluttering up your directory lists. The following code stashes them all in =~/.emacs.d/backups=, where I can find them with =C-x C-f= (=find-file=) if I really need to.

#+begin_src emacs-lisp
(setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
#+end_src

Disk space is cheap. Save lots.

#+begin_src emacs-lisp
(setq delete-old-versions -1)
(setq version-control t)
(setq vc-make-backup-files t)
(setq auto-save-file-name-transforms '((".*" "~/.emacs.d/auto-save-list" t)))
#+end_src
** History
From http://www.wisdomandwonder.com/wordpress/wp-content/uploads/2014/03/C3F.html
#+begin_src emacs-lisp
(setq savehist-file "~/.emacs.d/savehist")
(savehist-mode 1)
(setq history-length t)
(setq history-delete-duplicates t)
(setq savehist-save-minibuffer-history 1)
(setq savehist-additional-variables
      '(kill-ring
        search-ring
        regexp-search-ring))
#+end_src
* Startup
** Maximize window (Windows only)
#+BEGIN_SRC emacs-lisp

 (if (eq system-type 'windows-nt)
   (tool-bar-mode 1)
   (w32-send-sys-command 61488) ; Does not work with toolbar diabled, so put that on a hook above
  )

;   (add-hook 'after-init-hook '(lambda () (w32-send-sys-command #xf030))))

(setq initial-frame-alist (quote ((fullscreen . maximized))))

#+END_SRC
** Open a file with agenda on startup 
  #+begin_src emacs-lisp 
;    (find-file "~/personal/organizer.org")
;    (require 'org-compat)
    (find-file (expand-file-name "jpg.org" org-directory))
    (run-at-time (format "%d sec" 1) nil '(lambda () (progn (org-agenda nil "A")) (other-window 1)))
;    (add-hook 'after-init-hook '(lambda () (progn (org-agenda nil "A") (other-window 1))))
  #+end_src
* Voice recognition (VR-mode)
Voice recognition mode should help using DNS in Emacs (http://emacs-vr-mode.sourceforge.net/)
#+BEGIN_SRC emacs-lisp
 (if (eq system-type 'windows-nt)
    (progn (add-to-list 'load-path (substitute-in-file-name "C:/Users/jpg/Progs/VR-mode/"))

      (setq vr-command "C:\\Users\\jpg\\Progs\\VR-mode\\vr.exe")
      (setq vr-win-class "Emacs")
      (load "vr")
    ;(autoload 'vr-mode "C:/Users/jpg/Progs/VR-mode/vr" "" t nil) 
))
#+END_SRC
* Remember for later (inactive)
** Auto install packages
https://github.com/allait/dotfiles/blob/master/emacs/emacs.d/packages.el
** Switch from horizontal to vertical split
#+BEGIN_SRC emacs-lisp :tangle no
(defun toggle-window-split ()
  (interactive)
  (if (= (count-windows) 2)
      (let* ((this-win-buffer (window-buffer))
             (next-win-buffer (window-buffer (next-window)))
             (this-win-edges (window-edges (selected-window)))
             (next-win-edges (window-edges (next-window)))
             (this-win-2nd (not (and (<= (car this-win-edges)
                                         (car next-win-edges))
                                     (<= (cadr this-win-edges)
                                         (cadr next-win-edges)))))
             (splitter
              (if (= (car this-win-edges)
                     (car (window-edges (next-window))))
                  'split-window-horizontally
                'split-window-vertically)))
        (delete-other-windows)
        (let ((first-win (selected-window)))
          (funcall splitter)
          (if this-win-2nd (other-window 1))
          (set-window-buffer (selected-window) this-win-buffer)
          (set-window-buffer (next-window) next-win-buffer)
          (select-window first-win)
          (if this-win-2nd (other-window 1))))))

#+END_SRC
   
